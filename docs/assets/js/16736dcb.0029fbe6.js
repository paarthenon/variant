"use strict";(self.webpackChunkvariant_site=self.webpackChunkvariant_site||[]).push([[1568],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(n),d=a,f=u["".concat(c,".").concat(d)]||u[d]||m[d]||i;return n?r.createElement(f,o(o({ref:t},p),{},{components:n})):r.createElement(f,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5894:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return u}});var r=n(3117),a=n(102),i=(n(7294),n(3905)),o=["components"],l={title:"Internal Semantics"},c=void 0,s={unversionedId:"articles/semantics",id:"articles/semantics",title:"Internal Semantics",description:"You'll know if you should be reading this.",source:"@site/docs/articles/semantics.md",sourceDirName:"articles",slug:"/articles/semantics",permalink:"/variant/docs/next/articles/semantics",draft:!1,tags:[],version:"current",frontMatter:{title:"Internal Semantics"},sidebar:"someSidebar",previous:{title:"Naming Conventions",permalink:"/variant/docs/next/articles/naming"},next:{title:"That type annotation",permalink:"/variant/docs/next/articles/that-type"}},p={},u=[{value:"Variant",id:"variant",level:2},{value:"VariantCreator",id:"variantcreator",level:2},{value:"Variant Record",id:"variant-record",level:2}],m={toc:u},d="wrapper";function f(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)(d,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"You'll know if you should be reading this.")),(0,i.kt)("h2",{id:"variant"},"Variant"),(0,i.kt)("p",null,'A variant is some arbitrary algebraic data type. TypeScript does not have any top-level ADT syntax like OCaml so we cannot conjure tag constructors into scope on a whim. Note that even if we manage to create tag constructors and instances they will be inherently structural, and so behave more like polymorphic variants than traditional variants i.e. they have no inherent relation to each other. This is heavily emphasized in the section on "organization".'),(0,i.kt)("p",null,"A variant definition is a collection of tag constructors a.k.a. ",(0,i.kt)("inlineCode",{parentName:"p"},"VariantCreator")," stored as an object sometimes called the ",(0,i.kt)("strong",{parentName:"p"},"Variant Record")," or ",(0,i.kt)("strong",{parentName:"p"},"Variant Module"),"."),(0,i.kt)("h2",{id:"variantcreator"},"VariantCreator"),(0,i.kt)("p",null,"A variant creator is a function that returns an object and possesses several extra properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a symbol that announces the function as a variant creator. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"creator.type"),", the string literal used as the type for this form."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"creator.toString()")," renders ",(0,i.kt)("inlineCode",{parentName:"li"},"creator.type"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"creator.name")," copies ",(0,i.kt)("inlineCode",{parentName:"li"},"creator.type"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"creator.key")," is the string literal used as the discriminant key.")),(0,i.kt)("p",null,"So it is possible to inspect a random creator function and determine the type it will output. This can be leveraged in procedural generation."),(0,i.kt)("p",null,"It's also possible to check whether or not a function is a variant creator by looking for the brand. The ",(0,i.kt)("inlineCode",{parentName:"p"},"variant()")," function takes advantage of this feature to transparently pass through variant creators (calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"variation"),"). This may be done when recombining a variant or when adjusting the underlying type of some variation. "),(0,i.kt)("h2",{id:"variant-record"},"Variant Record"),(0,i.kt)("p",null,"The internal construction of a variant is as an object. Each value is the result of a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"variation"),". ",(0,i.kt)("em",{parentName:"p"},"There are no requirements regarding the keys.")," By convention the keys will match the string literal registered to the ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," field (or other discriminant)"))}f.isMDXComponent=!0}}]);