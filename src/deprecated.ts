/**
 * THIS FILE is for the content I intent to remove on Variant 3.0 that
 * I'm tired of seeing or considering in the code, so it gets shuffled
 * off to here.
 */
import {Defined, Handler, match} from './match';
import {Func, Identity} from './util';
import {Outputs, Property, VariantModule, VariantsOfUnion} from './variant';


/**
 * @deprecated
 * A variant with some extra properties attached (use augmented instead)
 */
export type AugmentVariant<T extends VariantModule, U> = {
    [P in keyof T]: ((...args: Parameters<T[P]>) => Identity<ReturnType<T[P]> & U>) & Outputs<T[P]['key'], T[P]['type']>
}

/**
 * @deprecated
 * Expand the functionality of a variant as a whole by tacking on properties
 * generated by a thunk.
 * @param variantDef 
 * @param f 
 */
export function augment<T extends VariantModule, F extends Func>(variantDef: T, f: F) {
    return Object.keys(variantDef).reduce((acc, key) => {
        const augmentedFuncWrapper = (...args: any[]) => (Object.assign({}, f(), variantDef[key](...args)));
        return {
            ...acc,
            [key]: Object.assign(augmentedFuncWrapper, {key: variantDef[key].key, type: variantDef[key].type})
        };
    }, {} as AugmentVariant<T, ReturnType<F>>);
}



/**
 * Built to describe an object with the same keys as a variant but instead of constructors
 * for those objects has functions that handle objects of that type. In this case, the
 * keys are all partial and there is an extra option "default"
 */
export type DefaultedHandler<T, U = any> = Partial<Handler<T> & {default?: (union: T[keyof T]) => U}>

/**
 * Match a variant against some of its possible options and do some
 * processing based on the type of variant received. May return undefined
 * if the variant is not accounted for by the handler.
 * @deprecated
 * @param obj 
 * @param handler 
 * @param typeKey override the property to inspect. By default, 'type'.
 */
export function partialMatch<
    T extends Property<K, string>,
    K extends string = 'type'
> (
    obj: T,
    handler: DefaultedHandler<VariantsOfUnion<T, K>>,
    typeKey?: K,
): ReturnType<Defined<typeof handler[keyof typeof handler]>> {
    return match(obj, handler as any, typeKey) as any;
};


/**
 * Match a variant against it's some of its possible options and do some 
 * processing based on the type of variant received. Finally, take the remaining
 * possibilities and handle them in a function.
 * 
 * The input to the 'or' clause is well-typed. 
 * 
 * @deprecated
 * @param obj the variant in question
 * @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
 * @param {string?} typeKey override the property to inspect. By default, 'type'.
 * @returns {The union of the return types of the various branches of the handler object}
 */
export function matchElse<
    T extends Property<K, string>,
    H extends Partial<Handler<VariantsOfUnion<T, K>>>,
    E extends (rest: Exclude<T, Property<K, keyof H>>) => any,
    K extends string = 'type'
> (
    obj: T,
    handler: H,
    _else: E,
    typeKey?: K,
): ReturnType<Defined<H[keyof H]>> | ReturnType<E> {
    const typeString = obj[typeKey ?? 'type' as K];
    return handler[typeString]?.(obj as any) ?? _else(obj as any)
}
